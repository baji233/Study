## 从输入 URL 到页面加载的全过程

- URL解析

- 检查浏览器是否有缓存

- DNS域名解析

- TCP连接

- HTTP请求

- 服务器处理报文并响应请求

- 浏览器渲染

- TCP断开连接

  

1.输入URL地址，解析URL地址分析所需要使用的传输协议、域名和请求的资源的路径

2.浏览器查找强缓存，首先会根据请求头的`expires`和`cache-control`判断强缓存是否在有效期内，判断是否向远程服务器请求资源还

是去本地磁盘获取缓存资源。

3.在进行URL的DNS域名解析之前，先访问浏览器缓存和操作系统(OS)缓存是否存在ip地址的记录、

（递归查询：主机向本地域名服务器的查询一般都是采用递归查询）

 若都未命中，则询问本地域名服务器，本地域名服务器会递归式的查找域名IP地址，如果主机所询问的本地域名服务器不知道被查询的域

名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，查询到ip地址

后返回立即返回给主机，随后结束查询

（迭代查询：DNS服务器之间的查询属迭代查询）

本地域名服务器向**根域名服务器**、**顶级域名服务器**、**权威域名服务器**继续发出迭代查询请求，其他域名服务器要么给出所要查询的IP地

址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。将查询的ip地址返回给本地域名服务器，随后结束查询

4.与服务器建立TCP链接，向服务器发送http请求，若协议是https则会做加密；

5.服务器接受请求并解析，检查HTTP请求头中包含的缓存验证信息 **if-none-match** 字段和 **If-Modified-Since**字段，根据资源的是否被修改判断是否命中缓存，如果资源没有更新则返回304并且不会返回资源内容，如资源更新了则直接返回资源，并且客户端更新缓存验证信息。

6.服务器将响应报文通过TCP连接发送给浏览器

7.浏览器接收响应，若响应状态码为304，浏览器则读取本地缓存

8.否则浏览器解析HTML文档，解析到`style`标签则开始解析css，如果解析到link标签，于是向服务器请求文件，注意link文件在请求和

下载文件过程中将继续向下解析HTML，当引入文件下载完成后会通知浏览器回头来解析；是非阻塞的。如果遇到`script`标签，判断

是行内写法则直接解析执行，如果是向服务器请求js文件，会等待文件下载完成，立即执行，执行完毕后再向下解析，是阻塞的。因此要

将script标签置于body底端。

浏览器渲染页面的过程主要是解析html文档组成` dom树`，解析css形成` css规则树`，dom树和css规则树共同组成`渲染树`，当浏览器生成渲

染树以后，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的所属关系，就会根据渲染树进入布局处理阶段，即计算

出每个节点在屏幕中的位置，再下一步就是绘制，即遍历RenderTree，并根据计算好的节点信息绘制整个页面。

9.浏览器关闭TCP连接



## 为什么要将Script标签放在body标签的底部

当浏览器拿到服务器返回的资源之后，开始渲染页面同时获取HTML页面中图片、音频、视频、CSS、JS文件，在这期间获取到JS文件之后，会直接执行JS代码，阻塞浏览器渲染，因为渲染引擎和JS引擎互斥，不能同时工作，如果获取 JS 脚本的网络请求迟迟得不到响应，或者 JS 脚本执行时间过长，都会导致白屏，用户看不到页面内容，所以通常把Script标签放在body标签的底部。 



## 浏览器使用缓存的好处

- 减少不必要的数据传输

- 减少服务器负担

- 加快客户端加载网页的速度

  



## 三次握手、四次挥手

刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。 进行三次握手：

第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号。客户端发送完SYN报文以后，自己便进入了**SYN_SEND **状态

第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号，同时会把客户端的 初始化序列号 + 1 作为ACK 字段的值，表示自己已经收到了客户端的 SYN报文，此时服务器处于 **SYN_RCVD** 的状态。

第三次握手：客户端收到服务端发送的报文后，就知道服务端已经接收到了自己的序列号，此时，客户端需要告诉服务端自己已经接收到了他发送过来的序列号，所以会把服务器的初始化序列号+ 1 作为 ACK 报文的值，将这个ACK报文发送给服务端，表示已经收到了服务端的 SYN 报文，此时客户端处于 **estalished** 状态。服务器收到 ACK 报文之后，也处于 **estalished** 状态，此时，双方已建立起了连接。



四次挥手：

当客户端第一次发送 FIN 报文之后，只是代表着客户端不再发送数据给服务端，但此时客户端还是有接收数据的能力的。而服务端收到FIN报文的时候，可能还有数据要传输给客户端，所以只能先回复 ACK报文给客户端，服务器进入 CLOSE_WAIT 状态，等到服务端不再有数据发送给客户端时，才发送 FIN 报文给客户端，服务器进入LAST_ACK状态，客户端收到服务端的FIN报文之后，回应ACK报文，自己进入 TIME_WAIT 状态，服务端收到客户端的ACK报文之后，服务端就进入 CLOSE 状态，客户端在TIME_WAIT等待4分钟内服务端未重发FIN报文时，也进入了 CLOSE 状态，TCP连接就关闭了。



## TIME_WAIT状态的作用

1、确保接收方能正常获取到ACK报文，正常终止连接，若没有获取到，接收方会重新发送FIN报文

2、确保在创建新连接时，先前网络中残余的数据都被丢弃了，不会影响到下一个连接



## 为什么需要三次握手，两次不行吗？

第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：双方的接收、发送能力是正常的。不过此时服务器并不能确认客户

端的接收能力是否正常。

第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：双方的接收、发送能力是正常的。



## 为什么是四次挥手？

客户端打算关闭连接时，当客户端第一次发送 FIN 报文之后，只是代表着客户端不再发送数据给服务端，但此时客户端还是有接收数据的能力的。而服务端收到FIN报文的时候，可能还有数据要传输给客户端，所以只能先回复 ACK报文给客户端，等到服务端不再有数据发送给客户端时，才发送 FIN 报文给客户端，客户端收到服务端的FIN报文之后，回应ACK报文，就可以关闭了。

两个来回就四次了



## HTTP和HTTPS

HTTP：是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，是一个客户端和服务器端请求和应答的标准，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。

HTTPS：HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证 这些隐私数据能加密传输，使用SSL协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。

HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。

区别：

1、https协议需要申请证书，需要一定费用。

2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议，比http安全。

3、http协议默认端口是80、https协议默认端口是443



## https加密过程（SSL四次握手的过程）

使用非对称加密的方式生成对话密钥，以后的对话过程都使用这个对话密钥来加密

1、客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法

2、服务器收到请求后，确认双方使用的加密方法，并返回出服务器的证书，以及一个服务器生成的随机数

3、客户端确认服务器的证书有效后，生成一个新的随机数，并使用数字证书中的公钥加密这个随机数，并将它发送给服务器。并且还会携带一个前面所有内容的 hash 的值，用来供服务器检验。

4、服务器使用数字证书中的私钥，来解密客户端发过来的随机数，并返回前面所有内容hash值，供客户端检验

5、客户端和服务器根据约定好的加密方法使用前面的三个随机数，生成一个对话密钥，以后的对话过程都使用这个密钥进行加密



- 对称加密算法采用协商的秘钥对数据加密
- 非对称加密实现身份认证和秘钥协商





## 强缓存与协商缓存

- 强缓存：与expires 字段和 cache-control 字段有关。通过在响应头设置expires字段，过期时间是由服务器返回的，然后客户端在过期时间内再次发起请求时，资源都会走本地缓存，而不会重新请求。其实 cache-control 字段跟 expires 字段效果差不多，只不过这两个字段设置的值不一样而已，expires字段设置的值是一个绝对时间，是由服务器端返回的，当浏览器本地时间和服务器时间不一致时会产生误差，浏览器会直接向服务器请求新的资源。cache-control字段可以解决这个问题。cache-control字段设置的是相对时间，设置资源可以被缓存多长时间（max-age），单位为秒；当下次发起请求时在这个时间段内，会读取缓存。



- 协商缓存：强缓存在有效时期内，不会向服务器发起缓存，只读取本地缓存，而协商缓存是会发起请求的，如果请求服务端某个资源，发现`命中缓存`则返回`304`，否则则返回所请求的资源

  1、通过 Last-Modified 与 If-Modified-Since两个字段配合实现：

  - 第一次请求服务器资源时，服务器把资源最后修改时间当成响应头中Last-Modified的值，传到浏览器并保存起来

  - 第二次请求时，浏览器会把上次请求的 Last-Modified 的值作为请求头字段 If-Modified-Since 的值发送给服务器，根据 If-Modified-Since 的值和该资源的最后修改时间对比，判断是否命中缓存

  - `命中缓存`，那就返回`304`，`没命中缓存`，则返回修改过后的新资源

    

  2、通过Etag，If-None-Match 两个字段配合实现（弥补了上面的一些小问题）

  - 第一次发请求响应时，ETag的值由服务器生成返回给前端，它是一个文件的唯一标识符，当资源发生变化时，服务端就是生成新的ETag返回给前端

  - 第二次请求时，请求头会带上 if-none-match 字段，它的值为ETag的值，服务器收到请求进行比对if-none-match的值和服务器保存的Etag字段，判断资源是否更新

  - 发送请求时，浏览器对Etag优先级是高于Last-Modifed的，所以服务器会优先验证Etag

  - 因为Etag的出现主要是解决`last-modified` 出现的问题

    有些情况下仅判断最后修改日期来验证资源是否有改动是不够的：
    因为Last-Modified无法精确到毫秒，但有些资源更新频率在一秒以内，所以在1秒内对资源进行更新时，使用Last-Modified字段无法正常的判断资源是否更改





## GET方法与POST方法的区别，什么时候应该使用

get：一般用于获取信息，通过地址栏传参，对发送的信息数量限制在2000个字符左右

post：一般用于修改服务器资源，对发送的信息数量没有限制，通过body传参

使用场景：

get：一般用于获取信息

post：向服务器发送大量数据、无法使用缓存文件时、发送包含未知字符的用户输入时

常见请求方式：get、post、put、patch（局部更新）、delete、connect、trace



## cors解决跨域原理

简单请求：（`GET`、`HEAD`、`POST`，没有自定义的头部字段）

就是在请求头中增加一个origin字段，表明了本次请求来自哪里，如果域名在服务器的允许范围之内，服务器返回响应，响应头中会包含一个Access-Control-Allow-Origin 字段，表明了服务器接收哪些域名的请求，哪些域名可以访问服务器资源，这样就完成了访问控制



非简单请求（不满足简单请求的条件）

会在正式通信之前进行一次预检请求，预检请求的请求方法是 `OPTIONS`，目的就是让服务器判断此次请求是否被允许，通过Access-Control-Request-Method字段表明了此次请求的方式，通过Access-Control-Request-Headers字段表明了自定义请求首部字段，服务器由这两个字段决定是否请求是否允许，服务器确认允许请求后，服务器在响应头中加上Access-Control-Allow-Methods字段，表明服务器支持的请求方式，Access-Control-Allow-Headers字段表面了服务器允许请求中携带的自定义头部字段，就可以开始正式请求了，请求的时候就会跟简单请求一样



## http1.1比http1.0的好处

1、http1.0默认是短连接，http1.1默认是长连接，在http1.0上设置请求头为connection:keep-alive，可以开启长连接，在http1.1上设置connection：close可以设置关闭长连接（过多空闲的长连接，会占用服务器资源，服务器可以设置长连接的过期时间，或者设置一个长连接最多处理的请求次数）

2、http1.1新增了一些请求方法比如put、Head（获取报文首部，与get相比，不会获取报文主体内容）、options（预检请求、一般在非简单请求前发送，一般用于获取服务器支持的所有请求方法，以及用来检查是否有访问权限）

3、新增了更多用于控制缓存的字段，比如ETag、If-Unmodified-Since、If-Match、If-None-Match等

4、http1.1新增了host字段host字段，用来指定服务器域名



## 队头阻塞

分为http1.0的队头阻塞（非管道化下）、http1.1的队头阻塞（管道化下的）

- http1.0的队头阻塞：发生在客户端

  由 HTTP 基本的“请求 - 应答”机制所导致的，只有得到上一个请求的响应，才会发起下一个请求，前一个请求如果因为网络延迟一直没有响应，则会阻塞后面的请求。阻塞的是客户端发出下一个请求

- http1.1的队头阻塞：发送在服务器端

  由于http1.1新增了管道化这一特性，当第一条请求发往服务器的时候，第二第三条请求也可以开始发送了，不用等到第一条请求响应回来。请求可以并发发出，但是响应要按照请求的顺序，后一个响应必须在前一个响应之后。所以可能会在服务器端发生阻塞，上一个响应迟迟不能发出，后面的响应也就不能发出

  

  管道化请求的致命弱点:

  会造成队头阻塞，前一个响应未及时返回，后面的响应被阻塞
  请求必须是幂等请求，也就是只有GET和HEAD请求才能管道化，不能修改资源。因为，意外中断时候，客户端需要把未收到响应的请求重发，非幂等请求，会造成资源破坏。
  由于这个原因，目前大部分浏览器和Web服务器，都关闭了管道化，采用非管道化模式。

  无论是非管道化还是管道化，都会造成队头阻塞(请求，响应阻塞)。

  



## http2比http1的好处

1、多路复用：一个TCP连接，可以同时发送多个请求或响应，而且不用按照顺序一一发送

解决的问题：

​        1、队头阻塞：http1.0采用请求-应答模式，一个请求响应了才会处理下一个请求，会存在一个请求队列，排在前面的请求先处理，

如果队首的请求处理时间太长，后面的请求就只能处于阻塞状态

​        2、在 http1.1 中，浏览器客户端在同一时间，针对同一域名下的连接数量有一定数量限制，超过限制的请求会被阻塞。

2、数据流：引入了数据流的概念，因为http2的数据包不是按顺序发出的，同一个连接里面的数据包，可能属于不同请求，因此将每个请求的请求和响应的所有数据包称为一个数据流，每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。

3、头信息压缩：因为http1协议的无状态，每次请求都必须附带上所有的请求信息，针对一模一样的请求信息，而很多请求的字段都是重复的，会浪费很多带宽、影响速度，http采用了头信息压缩的机制，一方面头信息经过gzip压缩或者compress压缩再发送，另一方面，客户端和服务器共同维护一张头信息表，所有字段都会存入这张表，并生成对应的索引号，每次首次发送请求以后，就不需要发送一样的字段了，只需要发送相应的索引号就行了

4、服务器推送：http2中允许服务器主动向客户端推送资源，这就是服务器推送，提前向客户端推送必要的静态资源，可以相对减少一些延迟时间

服务器推送的意义

- 提前将资源推送到浏览器
- 推送可以基于已发送的请求，例如客户端请求 `html`，服务端可以主动推送 `js`、`css` 文件



队头阻塞的解决办法：

- 并发连接 

  对一个域名发起多个连接，就相当于增加了任务队列，不至于一个队列里的任务阻塞了其他全部任务，浏览器标准中一个域

  名`长连接`可以有`6~8`个

- 域名分片  

  多准备几个`二级域名` 它们都指向同一台服务器，可以让不同的资源从不同的二级域名中获取，这样相当于增加了更多的连接了

- 多路复用（http2.0）

  一个TCP连接，可以同时发送多个请求或回应，而且不用按照顺序一一发送，请求包和响应包都有唯一标识，所以不用按照顺序

  



## 浏览器重排（回流）与重绘

重排：当我们对 DOM 的修改了 DOM 宽、高、位置或隐藏元素（不占空间）等，浏览器需要重新计算元素几何属性和位置（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来

触发方式：

添加或者删除可见的DOM元素；

元素尺寸改变——边距、填充、边框、宽度和高度

元素位置发生变化

内容变化，比如用户在input框中输入文字

浏览器窗口尺寸改变——resize事件发生时

计算 offsetWidth 和 offsetHeight 属性（浏览器为了获取最新的页面信息，会导致浏览器强制刷新队列，引发重排和重绘）

设置 style 属性的值



重绘：当我们对 DOM 的修改导致了样式的变化比如修改了颜色或背景色时，浏览器不需重新计算元素的几何属性和位置、直接为该元素绘制新的样式

触发方式：

- 改变 color、background 、border-radius、visibility、box-shadow 等相关属性

  

## 减少重排重绘的办法

- 操作 DOM 时，尽量在低层级的 DOM 节点进行操作，影响更少的dom节点

- 使用 visibility 替换 display: none （将重排变成重绘）

- 减少使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局

- 避免频繁更新style样式，或者为元素添加class或者替换class来更新元素的样式

- 要操作dom之前，通过display隐藏dom，当操作完成之后，才将元素的display属性为可见，因为不可见的元素不会触发重排和重绘。

- 使元素脱离文档流，如浮动、position属性为absolute或fixed的元素，重排开销比较小，不用考虑它对其他元素的影响

  


## display、visibility、opacity

opacity：用来设置透明度(0-1)
display：用来定义建立布局时元素生成的显示框的类型(‘block’,‘inline’,‘inline-block’,‘table’,‘none’,‘list-item’)
visibility：用来设置元素是否可见(‘visible’,‘hidden’)

1. 是否占据了空间
   - opacity、visibility 不显示仍占据空间
   - display 不显示不占据空间
2. 对子元素的影响
   - 如果父元素和子元素的显隐性不同（父隐子显），opacity、display子元素的设置不起作用，显示效果和父元素一样
   - visibility 不受父元素影响，可以显示出来
3. 是否影响其他元素的触发事件
   - visibility,display 不会影响其他元素触发事件
   - opacity 属性如果能遮住其他元素，其他元素则不能触发事件（用在一个遮罩覆盖底层页面，并且不触发底层事件，却能触发自身事件的情形）
4. 是否产生了回流
   - display 属性会产生回流
   - opacity，visibility 属性不会产生回流



## 浏览器渲染页面

浏览器渲染页面的过程主要是解析html文档组成`标签节点树`，解析css形成`样式规则树`，标签节点树和样式规则树共同组成`渲染树`，浏览器最终显示渲染树形成页面。

1. 浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。
2. 将CSS解析成 CSS Rule Tree（css规则树） 。
3. 解析完成后，浏览器引擎会根据DOM树和CSS规则树来构造 Render树。注意：Render Tree 渲染树并不等同于 DOM 树，因为一些像Header或display:none的东西就没必要放在渲染树中了。
4. 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS以及各个节点间的关系。下一步进入布局处理阶段，即计算出每个节点在屏幕中的位置。
5. 再下一步就是绘制，即遍历Render树，并绘制每个节点。根据计算好的信息绘制成整个页面。



进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位



## 响应式原理

vue2响应式原理

数据的更改会引起页面的更新

是由数据劫持实现的，vue2是利用Object.defineProperty为data对象中的所有属性设置一个getter、setter函数，当使用属性值时，会触发getter函数，返回属性值，当修改属性值时，就会触发setter函数，除了会更新属性值，还会重新解析模板、生成新的虚拟dom，进行虚拟dom的diff比对算法，将页面需要更新的那一部分内容进行更新，就做到数据更改引起页面更新

```js
// 源数据
let person = {
  name: '张三',
  age: 18
}

// 模拟 Vue2 中实现响应式
let p = {}
Object.defineProperty(p, 'age', {
  // enumerable:true, // 控制属性是否可以枚举，默认值是false
  // writable:true, // 控制属性是否可以被修改，默认值是false
  // configurable:true, // 控制属性是否可以被删除，默认值是false

  //当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值
  get(){
	console.log('【检测到了】有人读取age属性了，我可以做一些事情了，这里是响应式的关键')
	return person.number
  },
  //当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值
  set(value){
	console.log('【检测到了】有人修改了age属性，且值是：', value)
	person.age = value
  }
})
```



 响应式的缺点：

1. 无法监听到对象属性的动态添加和删除“this.$set”

   “this.$delete”

2. 直接通过修改数组下标，界面不会更新





数据代理

通过一个对象代理另一个对象中的属性的读与写

vue中的数据代理：

通过组件实例对象来代理我们定义的data对象的属性读与写

好处就是可以更加方便的操作data中的数据

原理：通过Object.defineProperty把data对象中所有属性添加到组件实例上，并为每一个属性都设置一个getter、setter函数，用于去读和写data中的对应属性





vue3响应式原理

通过Proxy（代理）拦截对象中任意属性的变化，包括：属性值的读写、属性的添加、属性的删除等。

再通过Reflect（反射）对对象的属性进行操作

```js
let proxy = new Proxy(data, {
  // 拦截读取属性值
  get (target, prop) { // target:原对象； prop:读取的属性
    console.log(`监听到了属性值${prop}被读取`)
    return Reflect.get(target, prop)
  },
  // 拦截设置属性值或添加新属性
  set (target, prop, value) { // target:原对象； prop:要修改/增加的属性  value：值
    //target[prop] = value
    console.log(`监听到了属性值${prop}发生变化`)
    return Reflect.set(target, prop, value)
  },
  // 拦截删除属性
  deleteProperty (target, prop) {
    //return delete target[prop]
    console.log(`监听到了属性值${prop}被删除`)
    return Reflect.deleteProperty(target, prop)
  }
})

// proxy 就是源数据 data 的响应式代理对象
proxy.name = 'tom' // 触发监听
let age = proxy.age // 触发监听
delete proxy.name // 触发监听

```



## Vue3 中的响应式解决了 Vue2 中存在的问题

新增属性、删除属性、界面会更新了

直接通过下标修改数组，界面也会自动更新



## ref与reactive

reactive

将对象转换为Proxy代理对象

原理：

通过Proxy来实现响应式（数据劫持），并通过Reflect操作源对象的数据

ref

将基本数据转换为一个对象，将数据的值挂载到value属性上

原理：

定义基本数据类型：通过Object.defineProperty设置一个getter、setter函数进行数据劫持

定义对象、数组：内部自动通过reactive转为代理对象



## 什么是引用数据类型

js基本数据类型的值是直接存储在栈内的，变量指向栈内的数据

引用数据类型的值是存储在堆内的，栈内存储的是它的引用地址，引用数据类型直接赋值时，赋值的是它的存储地址，两个变量指向堆内存中的同一个对象，数据是共享的。



## 数组去重

数组去重优缺点

`var` `arr = [1,1,``'true'``,``'true'``,``true``,``true``,15,15,``false``,``false``, undefined,undefined, ``null``,``null``, NaN, NaN,``'NaN'``, 0, 0, ``'a'``, ``'a'``,{},{}];`

set去重

[...new Set(arr)]    缺点：无法去除对象

map去重（利用map结构的对象属性名不能重复的特性，来判断数组是否存在相同属性） 缺点：无法去除NaN

function arrayNonRepeatfy(arr) {

​    let map = new Map();

​    let array = new Array();  // 数组用于返回结果

​    for (let i = 0; i < arr.length; i++) {

​      if(map .has(arr[i])) {  // 如果有该key值

​        map .set(arr[i], true);

​      } else {

​        map .set(arr[i], false);   // 如果没有该key值

​        array .push(arr[i]);

​      }

​    }

​    return array ;

  }



双重for循环  利用indexOf去重、利用includes去重    缺点：//NaN、对象没有去重



**hasOwnProperty**    可以去除所有的

对象是否存在某个属性  将typeof item + item设置为属性名

function unique(arr) {

​    var obj = {};

​    return arr.filter(function(item, index, arr){

​        return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true)

​    })

}



## js异步执行机制

1. 所有任务都在主线程上执行，形成一个执行栈。

2. 同步任务会在执行栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后（如定时器的倒计时结束)，将注册的回调函数放入异步任务队列中。

3. 等待主线程把同步任务都执行完了，就依次读取异步任务队列中的回调函数到栈内等待主线程的执行。

   



## js事件循环

宏任务： script 标签内的整体代码、setTimeout 、setInterval 、setImmediate、ajax请求

1. 渲染事件（比如解析 DOM、计算布局、绘制）；
2. 用户交互事件（比如鼠标点击、滚动页面、放大缩小等）；
3. `setTimeout`、`setInterval`等；
4. 网络请求完成、文件读写完成事件。

微任务：  process.nextTick、Promise.then中的代码、await表达式下面的代码

- setTimeout属于宏任务
- Promise本身是同步的立即执行函数，Promise.then属于微任务
- async方法执行时，遇到await会立即执行表达式，表达式之后的所有代码放到微任务执行

//



一开始执行栈空,我们可以把**执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则**。**微任务** 队列空，**宏任务** 队列里有且只有一个 script 标签内的整体代码。

script 标签内的整体代码被推入执行栈，执行同步代码。在执行的过程中，会判断是同步任务还是异步任务，产生新的**宏任务**与 **微任务**，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 **宏任务** 队列，这个过程本质上是**宏任务**队列的 **宏任务** 的执行和出队的过程。

上一步我们出队的是一个**宏任务**，这一步我们处理的是**微任务**。但需要注意的是：当**宏任务** 出队时，任务是**一个一个**执行的；而 **微任务**出队时，任务是**一队一队**执行的。因此，我们处理**微任务** 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空

如果在执行微任务的过程中，产生了新的微任务，一样会将该微任务添加到微任务队列中，V8引擎一直循环执行微任务队列中的任务，直到队列清空才算执行结束。**也就是说在执行微任务过程中产生的新的微任务并不会推迟到下一个循环中执行，而是在当前的循环中继续执行**，这点是需要注意的。

总结：

**当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。宏任务执行完后，执行栈再次读取微任务队列里的任务，依次循环。**



## node事件循环

理解：node事件循环一共有3个队列、和两个异步模块。

- nextTick模块：process.nextTick函数中的代码
- 微任务模块：微任务


- Timer队列：用于处理setTimeout、setInterval等计时器。
- Poll队列：用于处理文件的读写、数据库操作、网络请求等操作等。
- Check队列：用于处理setImmediate的回调。



事件循环：

开始：执行完所有同步代码，事件循环初始化完成之后，查看Timer队列是否有任务，有的话就立即执行，否则进入到Poll队列。查看Poll队列是否有任务，有任务就立即执行，否则就停在Poll队列进行等待。

循环过程：若Check队列、Timer队列、Poll队列新增任务，就跳转到对应的队列中执行，然后回到Poll队列中继续等待

在每次执行队列任务之前，会先检查异步模块中的nextTick函数的回调、微任务队列是否为空。若不为空则会先清空nextTick函数的回调、微任务队列，再进行事件循环

 process.nextTick：属于异步模块里面，但不属于事件循环的一部分，会在事件循环之前执行。

微任务队列：执行时间在nextTick之后，在事件循环之前



## 什么是Promise

**Promise** 是异步编程的一种解决方案，通过new关键字创建promise对象，以一个回调函数作为参数，回调函数中就是一些异步操作，当promise对象中的异步操作执行完成之后，通过resolve、reject方法将这个promise对象的状态改变为成功或者失败，promise对象的状态为成功时，则会执行then方法，失败则会执行catch方法

promise对象可以得到异步操作执行的结果，然后再根据结果的状态来执行回调函数，使得控制异步操作更加容易

解决了多级回调嵌套、回调地狱问题（第一个的函数的输出是第二个函数的输入）



async await相当于改良版的Promise ，await 可以等待异步操作返回结果后再执行后面的代码，相当于一种同步效果

，也可以处理回调地狱问题，还可以处理 then 的调用链问题，使代码看起来会简洁些，使得异步代码看起来像同步代码



## 箭头函数this指向理解

箭头函数中的this是在函数定义的时候就确定下来的，无法通过call、apply、bind更改

它的this指向和定义它时所处的作用域中的this相同   

作用域分为全局作用域和函数作用域、全局作用域this指向window、函数作用域this指向函数调用者



## 三种改变定时器this指向的方法

如果没有特殊指向，setInterval和setTimeout的[回调](https://so.csdn.net/so/search?q=%E5%9B%9E%E8%B0%83&spm=1001.2101.3001.7020)函数中this的指向都是window。
这是因为JS的定时器方法是定义在window下的。

方法1；在外部函数中将this存为一个变量that，回调函数中使用该变量that，而不是直接使用this

方法2：使用箭头函数，箭头函数没有自己的this，它的this继承自外部函数的作用域。

方法3：bind方法



## js继承

es5之前的继承：

原型链继承（继承prototype）+ 构造函数继承(继承属性)

1. 构造函数继承：在子元素的构造函数里面，通过call方法=》Father.call(this,name);//继承实例属性，第一次调用Father()

2. 原型链继承：

   两种继承方式：

   - 第一种()：

     Son.prototype = new Father();//继承父类方法,第二次调用Father()

     Son.prototype.constructor = Son

   - 第二种：组合继承最大的问题就是无论什么情况下,都会调用两次父类构造函数: 一次是在创建子类型原型的时候, 另一次是在子类型构造函数内部。而这种不用调用两次父构造函数，称为寄生组合式继承

     var prototype = object.create(Father.prototype);//创建对象

     用Object.create()方法创建新对象，并使用现有对象提供新对象的proto。

     Sun.prototype =  object.create(Father.prototype);

     Sun.prototype.constructor = Sun;

   **object.create()** 接收两个参数:

   - 一个用作新对象原型的对象

   - (非必须的)一个为新对象定义额外属性的对象

   - 原理：

     ```js
     Object.create = function(p) {
         function f(){}
         f.prototype = p;
         return new f();
     }
     ```



es6之后的继承

class类继承  语法糖 简洁

通过extends关键字（继承prototype） + 在子类的构造函数中调用super()方法（继承this）

子类是没有自己的 this 对象的，它只能继承自父类的 this 对象，然后对其进行加工，而super( )就是将父类中的this对象继承给子类的。没有 super，子类就得不到 this 对象。



Es5与Es6继承的区别：

1、ES6 中A类会通过 extends 关键字继承B类的属性

而ES5中，构造函数 A 与 构造函数 B 并没有继承关系，即构造函数 A 没有继承构造函数 B上面的属性，只有A生成的实例上才有B上面的属性

2、super() 与 A.call(this) 的区别

在不是继承原生构造函数的情况下，A.call(this) 与 super() 在功能上是没有区别的

在继承原生构造函数的情况下，A.call(this) 与 super() 在功能上是有区别的

ES5 中 A.call(this) 中的 this 是构造函数 B 的实例，也就是在实现实例属性继承上，ES5 是先创造构造函数 B 的实例，然后在让这个实例通过 A.call(this) 实现实例属性继承

在 ES6 中，是先新建父类的实例对象this，然后再用子类的构造函数修饰 this，使得父类的所有行为都可以继承



## 数组方法

push、unshift、pop、shift、splice、concat、every、filter、forEach、join、indexOf、lastIndexOf、map、reverse、slice、some、sort、toString、valueOf、includes、reduce



## 组件间通信

子传父：

自定义事件、 `$parent` 、作用域插槽

$parent：一种[隐性的父子组件通信](https://v2.cn.vuejs.org/v2/style-guide/#%E9%9A%90%E6%80%A7%E7%9A%84%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8)，不利于后期的维护和调试；且父子组件的耦合度较高。

作用域插槽：就是把子组件的数据通过插槽的方式传给父组件使用，但是接受的参数只在该插槽作用域内有效，父组件接收子组件传过来的插槽数据，再根据插槽数据来设置插槽的内容

```js
// 子组件MyComponent中
<div>
  <slot :text="text" :count="1"></slot>
</div>
// 父组件中
<MyComponent v-slot="slotProps">
  {{ slotProps.text }} {{ slotProps.count }}
</MyComponent>
```



父传子：

props、`$refs`、v-model、`$children`、`$attrs`

`v-model`：（props+自定义事件的语法糖)  在vue2中相似的是.sync修饰符（vue3中已废弃）

可以实现将父组件的属性传给子组件，子组件通过 `$emit` 触发相应的事件修改父组件的数据

```js
// 父
<CustomInput v-model="searchText" />   
// 子
props: ['modelValue'],
emits: ['update:modelValue'],
```



`$children` ： this.$children[0].someMethod() // 调用第一个子组件的方法



父传孙：`$attrs`

`$attrs`：**$attrs里的内容是父组件传过来的，并且子组件未用props接收的值**

子组件传递给孙组件 `<Sun v-bind="$attrs" />`   然后孙组件再用props接收到 



孙传父：

`$listeners`   是在孙组件中使用

`$listeners ` 包含了子组件作用域绑定的自定义事件

子组件传递给孙组件 `<Sun v-on="$listeners" />`  

孙组件使用 ：this.$emit('getSun事件', '这是从孙组件发送给父组件的数据')



任意组件：`EventBus` 、`provide/inject` 、 `全局状态管理器` 、

`EventBus` 是中央事件总线，不管是父子组件，兄弟组件，跨层级组件等都可以使用它完成通信操作

```js
//挂载
import Vue from "vue"
Vue.prototype.$bus = new Vue()

// 自定义事件名 sendMsg
this.$bus.$emit("sendMsg", "这是要向外部发送的数据")

// 监听事件的触发
this.$bus.$on("sendMsg", data => {
  console.log("这是接收到的数据：", data)
})
```

`provide/inject`（子改变父组件的值，通过自定义事件，改变了但不是响应式的，也就是inject不会获取到最新的值，如果要让inject获取到最新的值，只能让父组件传递一个受监听的对象，这样改变了其属性（不能整个替换），inject就能获取到最新的值）

```
// 提供静态值
provide('foo', 'bar')

// 提供响应式的值
const count = ref(0)
provide('count', count)

// 注入值的默认方式
const foo = inject('foo')

// 注入响应式的值
const count = inject('count')
```


## 为什么data要使用一个函数

当我们组件中的data写成一个**函数**时，数据是以函数返回值形式定义的，这样每复用一次data，都会返回一份新的data，每个组件实例都有 **自己的作用域**，每个实例相互独立，不会相互影响，不会产生数据污染。

 当我们组件中的data写成一个**对象**时，对象是引用数据类型，它就会共用一个内存地址，在多次使用该组件时，改变其中一个组件的值会影响所有复用该组件的地方。



## 常用事件修饰符有哪些

1.prevent：阻止默认事件（常用）；

2.stop：阻止事件冒泡（常用）；

3.once：事件只触发一次（常用）；

4.capture：使用事件的捕获模式；

5.self：只有event.target(触发事件的元素)是当前操作的元素时才触发事件；event.currentTarget 指向的是监听器直接绑定的元素

5.native：监听组件根元素的原生事件（在组件标签上绑定原生事件时，如果没有这个修饰符，会被认作为自定义事件）

6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；



## 判断 == === 比较规则

===：

如果类型不同：则不相等

如果两个值都是true或者false，则相等

如果引用同一个对象或函数，则相等

如果两个都是null或者undefined，则相等



== ：

如果类型相同：进行===比较

如果一个是null，一个是undefined，则相等

如果一个是字符串一个是数字，则将字符串转换为数字再比较

如果一个是true或者false则转换为数字1或0，再进行比较



## 在mutation之外修改state

更改Vuex 的store 中的状态的唯一方法是提交mutation

使用mutation更改状态是为了配合开发者工具使用，使得状态修改更好的被记录，保存状态快照，实现时间漫游／回滚之类的操作。、

```js
this.$store.state.aaa = xxx
```

直接修改state时，store中的state能够改变，并且是响应式的，但是这个状态更改不会被开发者工具记录

所以需要开启严格模式，仅需在创建 store 的时候传入 strict: true； 在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。



## vue生命周期

vue2：（共11个）

beforeCreate、created、

beforeMount（组件挂载前）、mounted（组件挂载后）、

beforeUpdate（响应式数据改变后，dom树更新前）、updated（dom树更新后）、

beforeUnmount（组件实例被卸载之前，仍保留全部功能，清除计时器、DOM 事件监听器）、unmounted、

errorCaptured、捕获了后代组件传递的错误时调用，后代组件通过trycatch捕获的错误对象会传递给这个钩子函数

activated（当组件被插入到 DOM 中时调用）、deactivated  （组件缓存时，当组件从 DOM 中被移除时调用）

nextTick()



vue3：（共9个）除去 beforeCreate、created，合并为一个setup，其余前面都加上on



## js判断类型的方法

Object.prototype.toString.call()   //这个方法是最好了，可以明确的区分各种类型 ，

返回的是一个字符串 '[object xxx]' 其中xxx是判断的类型

缺点是不能准确判断`person`是自定义`Person`类的实例，返回都是"[object Object]"，而只能用`instanceof` 操作符来进行判断

如：``` console.log(person instanceof Person); // 返回为true``` 



typeof               //这个只能区分**基本类型**。 对于`null`、`array`、`object`来说，使用`typeof`都会统一返回`object`字符串。对于函数会返回function



Array.isArray()       //这个只用来区分数组



instanceof           //无法用来判断NaN、null、undefined



## js数据类型

在ES5的时候，我们认知的数据类型确实是 6种：`Number`、`String`、`Boolean`、`undefined`、`object`、`Null`

ES6 中新增了一种 `Symbol `。这种类型的对象永不相等，即始创建的时候传入相同的值，可以解决属性名冲突的问题，做为标记。
谷歌67版本中还出现了一种 `bigInt`。是指安全存储、操作大整数。
**所以：**准确来说目前JS数据类型总共有8种！

- Number
- String
- Boolean
- Null
- Undefined
- Object
- Symbol
- BigInt

**按照类型来分有基本数据类型和引用数据类型：**

**基本数据类型：**`String`、`Number`、`Boolean`、`Null`、`Undefined`、`Symbol`

**引用数据类型：**`Object`【Object是个大类，function函数、array数组、date日期...等都归属于Object】



## js实现深拷贝

待拷贝的对象第一层属性中没有引用类型数据

slice() 、concat() 和 assign() 方法、扩展运算符、for循环+将每个元素添加到一个新对象或者新数组

若第一层属性中有引用类型数据

JSON.stringify() 和JSON.parse()  （缺点：不能有undifind属性）

for循环加递归



若考虑循环引用问题

for循环加递归+使用map记录引用



## 闭包

一个父函数内部创建另一个子函数，通过子函数来访问这个父函数的局部变量

闭包形成的原理是作用域链，当前作用域可以访问上级作用域中的变量，

作用是能够让函数作用域中的变量在函数执行结束之后不被销毁，同时也能在函数外部可以访问函数内部的局部变量

出现的问题：垃圾回收器不会将闭包中变量销毁，于是就造成了内存泄露，内存泄露积累多了就容易导致内存溢出

应用举例：防抖节流





## BFC

块级格式化上下文，是一个css的一个布局概念

BFC的容器就是页面上一个完全隔离开的容器，容器中的元素绝对不会影响到外面的元素

BFC的特性

     1、子元素margin-top不会传递给开启bfc的父元素，(解决margin塌陷)。

     2、一个开启bfc的盒子垂直方向上的距离由与其他盒子的margin的和决定，(解决margin塌陷)

     3、bfc的区域不会与float的元素区域重叠。

     4、计算bfc的高度时，浮动元素也参与计算

     5、bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。

形成BFC盒子：

1.body 根元素 

2.float不为none 

3.position的值为absolute或者fixed

4.overflow为auto、scroll和hidden（overflow的值不为visible）

5.display的值为inline-block、inline-flex、flex、flow-root、table-caption、table-cell



BFC容器解决的问题

1.解决盒子塌陷的问题（浮动元素脱标令父元素高度坍塌、margin塌陷（2种情况））

2.解决自适应布局的问题（避免被浮动元素覆盖，需要让自适应的盒子形成BFC）

以常见的两栏布局为例。左边固定宽度并设置左浮动，右边不设宽，因此右边的宽度自适应，如果右边要是不加BFC的话就会被遮盖

3.解决外边距垂直方向重合问题



## ie盒模型和标准盒模型

标准盒模型：盒子宽高不包括padding和border

ie盒模型：宽高包含padding和border

如何指定：html页面的时候最顶上都会有一个DOCTYPE标签，只要在文档首部加了DOCTYPE申明，即使用了标准盒模型，而不加，则会由浏览器自己决定，则可能会触发怪异盒模型



## 前端性能优化的方式

代码：

1.减少触发浏览器重排重绘的dom操作

2.优化js代码结构，减少冗余代码

3.开启路由组件缓存

5.按需引入第三方依赖

6.适当的使用防抖和节流以取消无效请求，比如说表单提交频繁点击，路由切换时还有未完成的请求。

懒加载：

3.开启路由组件懒加载、图片懒加载、图片预加载

部署：

2.开启图片压缩、代码压缩、静态资源压缩

4.减少http请求，合理设置 HTTP缓存

5.静态资源开启CDN服务

6.对于不常变化的数据包括外部JS/CSS资源，可进行前端浏览器缓存

7.开启http/2（如多路复用：允许通过单一的 HTTP/2 连接同时发起多重的请求-响应消息）在 HTTP/1.1 协议中浏览器客户端在同一时间，针对同一域名下的同时请求数、总连接数有一定数量限制。超过限制数目的请求会被阻塞



页面渲染:

1.开启骨架屏，提升用户体验



## for of 循环获取value和for in 循环获取key

for of 循环的原理是`按照是否有迭代器规范来循环的`

使用 for of 循环，首先会先执行对象身上的 Symbol.iterator 属性对应的函数且返回一个对象 对象内包含一个函数 `next()` 循环一次执行一次 `next()`，`next()` 中又返回一个对象 ， 这个对象内包含两个值分别是代表循环是否结束的值、代表每次遍历的值 。`true 代表结束；value：代表每次返回的值`。

```js
// Symbol.iterator 内部机制如下
let arr = [12, 23, 34]
arr[Symbol.iterator] = function () {
    let self = this,
        index = 0;
    return {
        next() {
            if(index > self.length-1){
                return {
                    done: true,
                    value: undefined
                }
            }
            return {
                done: false,
                value: self[index++]
            }
        }
    }
}
```

`for in` 的循环性能循环很差。性能差的原因是因为：`for in` 会迭代对象原型链上一切 `可以枚举`的属性（一般是我们手动添加在原型对象上的属性才是可枚举的，原型对象上的属性默认是不可枚举的）。

- (缺点) `for in` 循环主要遍历属性名为数字的优先，由小到大遍历

- (缺点) `for in` 无法遍历属性名为 `Symbol`属性（不可枚举）。

- (缺点) `for in` 会遍历对象的所有的可枚举属性，包括原型。所以会将对象的(prototype) 中可枚举的属性也遍历了。可以使用

   `hasOwnProperty`来阻止遍历公有属性。



## script标签中的defer属性、async属性

<script> 标签默认是同步加载、立即执行的，会阻塞浏览器渲染引擎，使用这些属性可以变成异步加载的

默认script标签：

暂停解析，先发送网络请求获取该 JS文件，然后让 JS 引擎执行该js文件，当代码执行完毕后恢复解析

async：

请求该脚本的网络请求是异步的，不会阻塞浏览器解析 HTML，一旦网络请求回来之后，如果此时 HTML 还没有解析完，浏览器会暂停解析，先让 JS 引擎执行代码，执行完毕后再进行解析

多个 async script的时候，它们之间的执行顺序也不确定，完全依赖于网络传输结果，谁先到执行谁。

defer：

获取该脚本的网络请求也是异步的，不会阻塞浏览器解析 HTML，一旦网络请求回来之后，如果此时 HTML 还没有解析完，浏览器不会暂停解析并执行 JS 代码，而是等待 HTML 解析完毕再执行 JS 代码

多个 defer script 标签，浏览器会保证它们按照在 HTML 中出现的顺序执行，且会在文档渲染完毕后，`DOMContentLoaded`事件调用前执行。

| script 标签        | JS 执行顺序     | 是否阻塞解析 HTML |
| ---------------- | ----------- | ----------- |
| `<script>`       | 在 HTML 中的顺序 | 阻塞          |
| `<script async>` | 网络请求返回顺序    | 可能阻塞，也可能不阻塞 |
| `<script defer>` | 在 HTML 中的顺序 | 不阻塞         |

## 精确丢失问题

0.1+0.2 > 0.3

因为js中计算浮点数时会将浮点数转换为二进制，并不是所有的小数都能完整的转换为二进制，比如0.1转为二进制就是一串无限循环的二进制数，而js中小数点后的数最多只能存储52位，所以转换过程中存在误差，计算的结果也就存在误差了

解决：

1.使用 .toFixed(1) 保留一位小数

2.给每一位乘以10变成整数再将结果除以10



toFixed的舍入规则
toFixed的修约（舍入）规则并不是“四舍五入”，而是“四舍六入五成双”，也即“4舍6入5凑偶”。
这里“四”是指≤4 时舍去，"六"是指≥6时进上，"五"指的是根据5后面的数字来定，当5后有有效数字（不为0）时，舍5入1；当5后无有效数字时，需要分两种情况来讲：①5前为奇数，舍5入1；②5前为偶数，舍5不进。（0是偶数）

```
// 当保留2位小数时的判断

const a1 = 0.046; // 第3位小数为6
const a2 = 0.044; // 第3位小数为4
const a3 = 0.0451 // 第3位小数为5, 5后为 1-有效数字
const a4 = 0.0450; // 第3位小数为5, 5后为 0-无效数字，5前为偶数
const a5 = 0.04503; //第3位小数为5,  5后为 03-有效数字
const a6 = 0.045; // 第3位小数为5, 5后无有效数字，5前为偶数
const a7 = 0.035; // 第3位小数为5, 5后无有效数字，5前为奇数


console.log(a1.toFixed(2)); // 0.05
console.log(a2.toFixed(2)); // 0.04
console.log(a3.toFixed(2)); // 0.05
console.log(a4.toFixed(2)); // 0.04
console.log(a5.toFixed(2)); // 0.05
console.log(a6.toFixed(2)); // 0.04
console.log(a7.toFixed(2)); // 0.04
```



## 虚拟dom

虚拟DOM本质上是一个js对象，通过对象来表示真实的DOM结构。没有虚拟dom的话，每次DOM的更新浏览器都会从构建dom树开始从头到尾执行一遍流程。所以造成了很大的性能浪费。如果频繁触发回流与重绘，那么就很容易就影响性能。

解释：

在vue中，通过编译将template 模板转换成渲染函数(render ) ，执行渲染函数就可以得到一个虚拟节点树

将内存中的虚拟dom初始化其真实的dom

当我们修改vue实例中的data数据时候

针对新的数据，生成一条新的虚拟dom树

将此次生成好的虚拟dom树与上一次虚拟dom通过dif比对算法进行对比的

将对比出来的差异的部分，通过对虚拟dom的属性和子节点的递归构建出真实dom树，进行重新的真实dom的渲染



缺点：首次渲染大量dom时，会多一层虚拟dom转换，会比innerHTML计算慢一点



## css动画之贝塞尔曲线可以实现的动画效果

linear匀速、ease先慢后快再慢、ease-in先慢后快、ease-out先快后慢、

ease-in-out先慢后快再慢，和ease的区别就是开始更慢一些，结束更慢一些





## Session+cookie的认证机制

作用是支持你在发送不同请求之间，记录并验证你的登录状态的一种机制。

客户端请求服务端，服务端会为这次请求开辟一块`内存空间`，这个对象便是 Session 对象，服务器可以利用 Session 存储客户端在同一个会话期间的一些操作记录。



如何认证：

服务器第一次接收到请求时，开辟了一块 Session 空间（创建了Session对象），同时生成一个 sessionId ，并通过响应头的Set-Cookie字段 **Set-Cookie：JSESSIONID=XXXXXXX **，向客户端发送要求保存Cookie 的响应； 客户端收到响应后，在本机客户端设置了一个 **JSESSIONID=XXXXXXX **的 Cookie 信息，如果 Cookie 不包含到期日期，Cookie 存储在内存中，不会写入磁盘，当浏览器关闭时，此后 Cookie 将永久丢失，如果 Cookie 包含`有效期` ，在到期指定的日期，Cookie 将从磁盘中删除。



接下来客户端每次向同一个域名发送请求时，请求头都会带上该 Cookie信息（包含 sessionId ）， 然后，服务器通过读取请求头中的 Cookie 信息，获取名称为 JSESSIONID 的值，得到此次请求的 sessionId。服务器即可验明客户端的身份。





## cookie的弊端

1、`Cookie`存在4kb大小的限制（每个浏览器有差别）。

2、每个特定的域名下最多生成的cookie个数有限制

3、安全性问题，默认存储以及默认发送的行为，存在一定的安全性问题，而且Cookie 是存储在浏览器中的，而且浏览器也提供了读写 

Cookie 的 API，因此Cookie 很容易被伪造

5、存在跨域限制

4、IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie





## css选择器优先级

特等：！important;

第一等：代表内联样式，如: style=””，权值为1000。
第二等：代表ID选择器，如：#content，权值为0100。
第三等：代表类，伪类和属性选择器，如.content、:nth-child()、[type='text']，权值都为0010。
第四等：代表类型（标签）选择器和伪元素选择器，如div、::after，权值为0001。
第五等：通配符、子选择器、相邻选择器等的。如*、>、+,权值为0000。
继承的样式没有权值。



## 盒子塌陷：

1. 由子元素浮动造成的高度塌陷

   解决办法：（也是清除浮动的影响的几种方式）

   1. 给父盒子设置固定高度
   2. 给父盒子开启BFC

      - 给父盒子也设置浮动
      - 给父元素设置overflow属性（auto或者hidden或者scroll）
      - 给父元素设置绝对定位或者固定定位
      - display的值为inline-block、inline-flex、flex
   3. 给父元素添加::after伪元素、设置属性clear: both，并且visibility:hidden;隐藏伪元素（最好）
   4. 父盒子里最后面添加一个空的div，并将设置clear ：both 属性（会增加无用的元素标签）
   5. 父盒子里最后面添加一个空的br，在br标签中设置属性clear，并赋值all  （会增加无用的元素标签)

2. 垂直方向marin塌陷问题:

   - 两个元素都设置了垂直相反方向的margin值，两个元素之间没有其他内容进行隔离，导致两个margin相遇，发生margin塌陷，只会显示较大的margin。

     解决办法：其中一个元素开启bfc；或者只给一个元素设置margin-top

   - 由子元素设置margin-top后，会传递给父级元素，带来marin塌陷问题 (本身父元素与上一个元素的距离是0，子元素如果设置了垂直方向的上边距，会带着父级元素一起掉下来（父元素的上边距0塌陷到了子元素的上边距50里面）)

     解决办法：主要思想是不要让子盒子和父盒子顶部贴合一起

     1. 给父盒子添加border
     2. 给父盒子设置padding-top
     3. 利用伪元素给子元素的前面添加一个元素
     4. 给父盒子开启BFC
        - 给父盒子设置浮动
        - 给父元素设置overflow属性（auto或者hidden）
        - 给父元素设置绝对定位或者固定定位
        - display的值为inline-block、inline-flex、flex

   



## 设置水平垂直居中的方法

1、必须知道子元素宽高：

- absolute（top和left设置为50%） + 负margin（top和left设置为负子元素宽高一半）
- absolute（位置全设置为0） + margin auto
- absolute（top和left设置为calc(50% - 子元素宽高一半)）+ calc（计算属性）

2、不需要知道子元素宽高

- absolute（top和left设置为50%） + transform（translate设置为-50%）

- flex布局：display: flex; justify-content: center; align-items: center;

- 利用行内样式居中属性：父元素设置text-align: center; 子元素设置display: inline-block;  vertical-align: middle;

- 网格布局  父display: grid;   子：align-self: center; justify-self: center;

- table-cell属性，把普通元素，变为table元素

  父元素设置（子元素只能为行内块或者行内元素）

  ​    display: table-cell;

  ​    text-align: center;

  ​    vertical-align: middle;

  

## 类数组和数组

类数组：是一个对象或者数组，但必须满足：拥有length属性、属性名为数字、不具有数组构造函数Array的原型对象上的方法，可以通

过length属性获取到数组长度，可以利用for循环进行遍历、可以通过索引获取到元素、

常见类数组：函数的arguments对象、获取dom时返回的集合（如：document.querySelectorAll方法）

类数组转换为数组：

1. Array.prototype.slice.call（obj）
2. Array.from()方法
3. 扩展运算符  [...obj]



## 通过字面量创建字符串、通过new关键词创建字符串

let a = '123'     在栈中创建一个变量命名为a,将'123'存放进来

let b = new String('123')    通过用new()新建一个对象，存放于堆内存中。然后栈中创建变量b，并且存放堆中对象的地址，指向该对象。

a、b都可以调用String的原型上的方法

由于隐式类型转换的原因，所以str1 == str3结果是true，但str1 === str3结果是false。



## 判断对象身上是否包含某个属性

1、对象.hasOwnProperty('属性')

1. **和原型没关系 ，不会查找原型上的属性。**
2. **只判断自身属性的场景。**

2、**对象.属性 != undefined 、对象[属性]!= undefined   来判断对象是否含有某个属性。**  变量只能使有对象[变量]的形式

1. **会查找原型链上的属性。**
2. **不能用在对象的属性值存在，属性值为 undefined 的场景下。**

3、**属性 in 对象;**

1. **会查找原型链上的属性。**



## vue 中 $nextTick 作用与原理

**Vue 在更新 DOM 时是异步执行的。当数据发生变化，Vue将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再统一进行视图更新**

为了确保得到更新后的DOM，所以设置了 Vue.nextTick()，就是在下次DOM更新结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。





## js进制转换的方法

十进制数字或者字符串a    转换成其他进制

parseInt(a).toString(要转换的进制)  返回值为字符串



其他进制字符串转十进制

parseInt( 要转换的字符串，把这个数字当成几进制 )   返回值为数字



//其他转其他  `

`//先用parseInt转成十进制再用toString转到目标进制`




## 单页面和多页面

单页面：切换页面的时候不会重新加载整个页面，只会进行局部的更新，也就是根据前端路由规则，根据不同的url，渲染不同的组件

多页面：切换页面的时候会从原来的页面跳转到另外一个页面，整个页面都会重新渲染。



单页面好处：页面切换较快，节约性能，减少了不必要的页面渲染。

缺点：首屏渲染较慢（因为首次加载第一个页面的时候，会将所有的组件都一起下载过来，可以通过路由懒加载，实现组件的按需加载），SEO差（单页面很多内容是异步获取的。网络抓取工具更擅长对静态资源的抓取和分析。所以说单页面对SEO不友好）。



## 前端路由跳转的实现原理

两种模式：hash、history

区别：

hash：地址中带#，不美观，但是浏览器对哈希模式的兼容性更好，这两种模式改变url实现前端路由跳转时，都不需要重新加载页面，只是根据前端路由规则显示不同的组件。

原理：

hash：哈希模式中的#后面内容称为哈希值，浏览器通过绑定hashchange事件对哈希值的改变进行监听，如果发生改变，浏览器会通过创建的hanshHistory对象在浏览器的访问历史中增加一个记录，会去渲染对应的组件，实现了一种无刷新的页面跳转功能。

history：利用了HTML5中新增的pushState方法和replaceState方法，使用这两个方法去操作浏览器的历史记录栈，在当前已有的  back、forward（前进一步）、go  的基础之上，pushState方法用于向历史记录栈增加一个记录，replaceState用于向历史记录栈中替换某条记录，通过这两个方法可以实现无刷新的页面跳转功能。



history模式弊端：当我们改变url去访问/home这个前端页面地址，前端会根据路由规则匹配对应的组件然后将其渲染到页面上，此时如果我们刷新页面，浏览器会发起新的请求，并且会把/home这个页面地址一并视为请求的url，所以这样后端如果没有/home这个接口，那么就会返回404页面。而hash模式不会将#后面的/home前端页面地址包括在请求的url中，所以不会产生这种404的情况

解决办法：开发环境不会出现404问题，因为在 `vue-cli`  中  `webpack`  帮我们做了处理，而生产环境下，可以在 nginx 中配置检查路由参数对应的资源是否存在，如果 URL 匹配不到任何静态资源，就都重定向到 index.html。



## OSI七层模型

1、应用层

可以理解为页面，最靠近用户的一层，为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：`HTTP`，`HTTPS`，`FTP`，`websocket`

2、表示层

表示层提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层发送的数据能被另一个系统的应用层识别。主要的三个功能是数据格式转换、数据压缩、数据加密

3、会话层

会话层就是负责建立、管理和终止两个实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。

4、运输层

传输层是提供端到端的连接，即实现不同进程之间的通信。作用是为上层协议提供端到端的可靠和透明的数据传输服务。在传输层主要依赖TCP和UDP协议，TCP是一种是一种可靠的、面向连接的通信协议；UDP是一种不可靠、无连接的通信协议。

5、网络层

主要任务是为网络上的不同主机提供通信。通过`IP`寻址来建立两个节点之间的连接，网络层负责在网络中传送的数据单元是分组或包。它为运输层送来的分组，它通过路由选择算法，为分组通过通信子网选择最适当的路径，正确无误地按照地址传送给目的端的运输层。这一层就是我们经常说的`IP`协议层。网络层规定了数据包的传输路线，而运输层则规定了数据包的传输方式。

6、数据链路层

它的主要任务是负责在两个相邻结点之间的线路上无差错地传输以帧为单位的数据。就是在原始的、有差错的物理传输线路的基础上，采取 **将数据封装成帧、** **差错检测、** **差错控制**和**流量控制**等方法，将有差错的物理线路改进成逻辑上的无差错的数据链路，以便向他的上一层网络层提供高质量的服务。

 封装成帧：封装成帧就是在一段数据的前后分别添加首部和尾部，构成一个帧。此处的首部和尾部起到了一个界限的功能。

 差错控制：检测和纠正数据传输错误的方法

 流量控制：当AB两台设备在发送数据，如果A设备有较高的发送速度，而B设备只有较低的接收速度，那么就会造成不匹配，容易造成传输错误，因此就需要流量控制，使两方面的速率基本匹配。

7、物理层

实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流，如常见的网线、电缆。物理层为数据链层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么。



## TCP和UDP的比较

省略...



## [ let、const、var的区别是什么 块级作用域](https://www.cnblogs.com/ltfxy/p/16397347.html)

（1）块级作用域：块作用域由 { }包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：

- 内层变量可能覆盖外层变量
- 用来计数的循环变量泄露为全局变量

（2）变量提升：var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。

（3）给全局添加属性：浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。

（4）重复声明：var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的变量。const和let不允许重复声明变量。

（5）暂时性死区：在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用var声明的变量不存在暂时性死区。

（6）初始值设置：在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。

（7）指针指向：let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。





## 数组的排序算法

冒泡排序

相邻元素进行比较，大的向后移动，第一轮排序后，最大的元素就被移动到最后一位了，经过n-1次，最终排列好所有的元素



选择排序

和冒泡排序原理一样，相邻元素进行比较，大的先不移动，记录下该元素的索引值，后面遇到更大的元素，索引值再替换，这样经过一轮遍历后，就找到了最大的元素的索引值，再将它与最后一位元素进行位置更换，最大的元素就被移动到最后一位了，经过n-1次，最终排列好所有的元素



插入排序（效率比以上两种高）

插入排序的主要思想是每次取一个列表元素与列表中已经排序好的列表段进行比较，然后插入到合适的位置，得到一个新的排序好的列表段，递归最终获得排序好的列表。假设取第一个元素为已经排列好的列表段，然后取第二个元素，与列表段的最后一个元素进行比较，如果小于列表段的元素，就与第二个元素更换位置，如果大于，则不进行更换，至此，新的排列好的列表段就有两位元素了，按照这种方式，进行递归。



快速排序（效率最高）

//1、选择数组中间数作为基数，并从数组中取出此基数
//2、准备两个数组容器，遍历数组，逐个与基数比对，较小的放左边容器，较大的放右边容器；
//3、递归1，2步分别处理两个容器的元素。

//4、整个排序过程可以递归进行，直到每个分区都只有一个元素为止，使整个数据变成有序序列



## [MVVM](https://so.csdn.net/so/search?q=MVVM&spm=1001.2101.3001.7020)模式分为Model，View，ViewModel 三个部分

(1).[Model](https://so.csdn.net/so/search?q=Model&spm=1001.2101.3001.7020):数据层，包含数据实体和对数据实体的操作
(2).View:界面层，负责数据显示以及用户交互。
(3).ViewModel：关联层，将Model和View进行绑定，Model或者View更改时，实时刷新对方

**注意点**

1. View只做和UI相关的工作，不涉及任何业务逻辑，不涉及操作数据，不处理数据，只是根据数据显示UI页面。UI和数据严格的分开
2. ViewModel通过双向数据绑定将`View`和`Model`层连接了起来，不涉及任何和UI相关的操作，不更新UI，它所做的事情就是，数据更新时，将更新消息传达给view层，进行View更新，用户在View层进行了交互，修改了数据，ViewModel将修改数据的通知传达给Model层，进行数据的修改（这一步就是vue框架为我们做的事）。
3. `Model`是代表**数据模型**，在`Model`中定义数据修改和操作的业务逻辑。



## new 关键字所做的事情

**var obj = new Base();**

new Base()所做的事情

1. **var obj  = {};** 
2. **obj.__proto__ = Base.prototype;** 
3. **Base.call(obj);**
4. 返回obj

第一行，我们创建了一个空对象obj
第二行，我们将这个空对象的__proto__成员指向了Base函数对象prototype成员对象
第三行，我们将Base函数对象的this指针替换成obj，然后再调用Base函数，执行构造函数中代码，给这个对象添加属性和方法

第四行，返回这个对象



## 反射型XSS、存储型XSS、dom型XSS

存储型XSS：

存储型XSS又称为持久型XSS，是指：攻击者将XSS代码发送给了后端，而后端没有对这些代码做处理直接存储在数据库中。当用户访问网站时，又直接从数据库调用出来传给前端，前端解析执行XSS代码就造成了XSS攻击。

存储型 XSS 的攻击步骤：

1. 攻击者将恶意代码提交到目标网站的数据库中。
2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。

![存储性XSS](E:\前端学习\笔记图片\存储性XSS.png)

反身性XSS：

反射型 XSS 是指应用程序通过 Web 请求的请求参数携带恶意代码，并在后端未检验请求参数是否存在恶意代码的情况下，将其返回给用户浏览器。反射型 XSS 一般可以由攻击者构造带有恶意代码参数的 URL 来实现，在构造的URL 地址被打开后，其中包含的恶意代码参数由服务器拼接到 HTML 中，返回给浏览器，被浏览器解析和执行。这种攻击的特点是非持久化，必须用户点击包含恶意代码参数的链接时才会触发。

两种情况下会出现：

1.前端会直接将链接中的参数插到页面中，渲染页面时就会执行恶意代码，比如向用户提示弹窗信息，如果黑客恶意构建了这样一个带有恶意js代码或者html代码的链接，用户点击，我们的前端直接将参数插入到页面进行渲染时。

2.在搜索页面，一般会在url中携带输入的关键字，如果黑客恶意构建了这样一个带有恶意js代码或者html代码的参数的搜索链接，用户点击这个连接时，会跳转到我们的搜索页面，并且会执行恶意代码。

为了避免反射型 XSS 攻击，建议采用以下方式进行防御：

1. 对用户的输入进行合理验证（如年龄只能是数字），对特殊字符（如`<、>、'、"`以及 `<script>、javascript` 等进行过滤。
2. 根据数据将要置于 HTML上 下文中的不同位置（HTML 标签、HTML 属性、JavaScript 脚本、CSS、URL），对所有不可信数据进行恰当的输出编码。
3. 设置 HttpOnly 属性，避免攻击者利用跨站脚本漏洞进行 Cookie 劫持攻击。
4. （其实理解就是，返回参数不要和请求参数一致，对用户输入的参数进行验证，确保没有包含 HTML 或 JS 等代码）



DOM 型 XSS ：

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL。
3. 用户浏览器接收到响应后解析执行恶意代码
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。
5. DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。



如何预防DOM型XSS攻击
DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。

1. 在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。
2. 如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。
3. DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，<a> 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。




## Token存储在Cookie还是LocalStorage

token在客户端主要以下几种存储方式：

1、存储在localStorage中，每次调用接口的时候都把它当成一个字段传给后台

2、存储在cookie中，让它自动发送，不过缺点就是不能跨域

3、拿到之后存储在localStorage中，每次调用接口的时候放在HTTP请求头的Authorization字段里面。token 在客户端一般存放于localStorage、cookie、或sessionStorage中。



由于LocalStorage 和 SessionStorage 都可以被 javascript 访问，所以容易受到XSS攻击，如果做好适当的XSS防护，也是可取的。而cookie可以指定 httponly，来防止被Javascript读取，也可以指定secure，来保证token只在HTTPS下传输。**缺点就是：**不符合Restful 最佳实践。 容易遭受CSRF攻击（可以在服务器端检查Refer和Origin）。并且Cookie空间有限，而JWT一半都占用较多字节，而且有时你不止需要存储一个JWT。所以没有固定的选择。



## Cookie的字段

Cookie是通过http response header设置到浏览器的，Cookie各个参数详细内容：

Set-Cookie:http响应头，向客户端发送Cookie。

1. Name=value:每个Cookie必须包含的内容。
2. Expires=date:EXpires确定了Cookie的有效终止日期，可选。如果缺省，则Cookie不保存在硬盘中，只保存在浏览器内存中。
3. Domain=domain-name:确定了访问哪些inernet域中的web服务器可携带浏览器储存的Cookie，缺省为该web服务器域名。
4. Path=path:定义了访问web服务器哪些路径下的页面可携带服务器发送的Cookie。一般如果用户输入的URL中的路径部分从第一个字符开始包含Path属性所定义的字符串，浏览器就认为通过检查。如果Path属性的值为“/”，则Web服务器上所有的WWW资源均可读取该Cookie。同样该项设置是可选的，如果缺省时，则Path的属性值为Web服务器传给浏览器的资源的路径名。可以看出我们借助对Domain和Path两个变量的设置，即可有效地控制Cookie文件被访问的范围。
5. Secure:在cookie中标记该变量，表明只有当浏览器和Web Server之间的通信协议为加密认证协议时，即只有为https通信协议时，浏览器才向服务器提交Cookie。
6. Httponly:禁止javascript读取,如果cookie中的一个参数带有httponly，则这个参数将不能被javascript获取；httponly可以防止xss会话劫持攻击。




## 某个请求自动携带cookies的条件:

1. 本地已经缓存有cookies

2. 根据请求的URL来匹配cookies的domain、path属性，如果都符合才会发送。

   如果满足下面几个条件：

   拿一个Http POST请求来说  http://aaa.www.com/xxxxx/list

   1、浏览器端某个Cookie的domain字段等于aaa.www.com或者www.com

   2、都是http或者https，或者不同的情况下Secure属性为false

   3、要发送请求的路径，即上面的xxxxx跟浏览器端Cookie的path属性必须一致，或者是浏览器端Cookie的path的子目录，比如浏览器端Cookie的path为/test，那么xxxxxxx必须为/test或者/test/xxxx等子目录才可以

   **注：**上面3个条件必须同时满足，否则该Post请求就不能自动带上浏览器端已存在的Cookie




## cookies受跨域限制

登录成功后，server会通过`set-cookie`，将cookie设置到浏览器中，这样，下次访问同源下的api时，cookie就会被带上。

但是浏览器发起**跨域请求**的时候，是不会主动带上cookie的，解决跨域后（1.设置代理 2.服务器在响应头中添加 allow-origin），如果跨域请求需要携带cookie，还要允许跨域请求携带cookie

此时需要设置axios的withcredentials的属性为true，告诉浏览器在访问B服务器时，将B服务器的cookie带上，此时光前端设置还不行，还需要后端在响应头中添加 allow-withcredentials = true,这样就可以保证跨域请求也可以携带cookie。







使用cookie可能遭受CSRF攻击 ：

## CSRF攻击攻击原理及过程：

1. 用户打开浏览器，访问受信任网站A，输入用户名和密码请求登录服务器A；
2. 用户信息通过验证后，服务器A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到服务器A；
3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；
4. 网站B接收到用户请求后，并发出一个请求去访问服务器A
5. 浏览器根据网站B的请求，在用户不知情的情况下携带Cookie信息，向服务器A发出请求。服务器A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息处理该请求，由网站B发起的请求可以做很多事情，也可以携带恶意代码。以用户身份对服务器A进行恶意请求，攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF 能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账…造成的问题包括：个人隐私泄露以及财产安全。

![CSRF攻击2](E:\前端学习\笔记图片\CSRF攻击2.png)

![CSRF攻击](E:\前端学习\笔记图片\CSRF攻击.png)

CSRF攻击特点：

- 攻击时机：网站的cookie在浏览器中没有过期，不关闭浏览器或者退出登录
- 攻击前提：对目标网站接口有一定了解

CSRF安全防护:

- 区分是否为伪造请求
- 二次验证

**referer、origin校验：**

​        HTTP Referer、origin是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器该请求是从哪个页面链接过来的，origin告诉服务器该请求是从那个域名过来的，服务器因此可以获得一些信息用于处理。

**业务二次校验：**

- 修改密码，需输入原密码
- 交易系统设置交易密码
- 增加图形验证码校验
- 网银转账短信验证码 





## 如何理解js异步

js是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。

而渲染主线程承担着很多工作，如解析html、解析css、执行js，渲染页面

如果使用同步的方式，就可能会导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。

这样一来，一方面会导致繁忙的主线程白白消耗时间，另一方面导致页面无法及时更新、给用户造成卡死现象。

所以浏览器采用异步的方式来避免。具体做法是当某些任务发生的时候，比如计时器、网络请求、事件监听，主线程将任务交给其他线程去做，自身立即结束该任务的执行，转而执行后续代码，当其他线程完成的时候，将事先传递的回调函数包装成一个任务，加到消息队列的末尾。等待主线程调度执行

在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。